(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{182:function(t,e,r){"use strict";r.r(e);var i=r(0),a=Object(i.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),r("p",[t._v("本地环境是自己电脑自己配置的环境")]),t._v(" "),r("p",[t._v("开发环境是团队公用的开发环境")]),t._v(" "),r("p",[t._v("测试环境一般用于自动化测试，不过我们可以用于人工测试")]),t._v(" "),r("p",[t._v("预演环境使用 master 分支，使用部分生产环境是数据进行最后一步的测试")]),t._v(" "),r("p",[t._v("生产环境就是正式环境")]),t._v(" "),t._m(4),t._v(" "),r("p",[t._v("一个函数里面有2个任务 A任务 和 B任务  AB各需要1秒 也就是执行完这个函数要2秒。如果用多线程 它会不停切换执行任务 唯一的好处是 B无需等A执行完了才执行 结果还是用了2秒。")]),t._v(" "),t._m(5),t._v(" "),r("p",[r("a",{attrs:{href:"https://medium.com/@buddhiv/how-to-directly-print-from-your-browser-using-qz-tray-6c86ccd7b3f9",target:"_blank",rel:"noopener noreferrer"}},[t._v("qz 破解教程"),r("OutboundLink")],1)]),t._v(" "),t._m(6),t._v(" "),t._m(7)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"其他"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他","aria-hidden":"true"}},[this._v("#")]),this._v(" 其他")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"页面加载流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#页面加载流程","aria-hidden":"true"}},[this._v("#")]),this._v(" 页面加载流程")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ol",[r("li",[r("p",[t._v("浏览器开启线程进行协议判断")])]),t._v(" "),r("li",[r("p",[t._v("解析 URL")])]),t._v(" "),r("li",[r("p",[t._v("DNS 解析获取 IP，发送信息")])]),t._v(" "),r("li",[r("p",[t._v("服务器处理逻辑，读取缓存或查询数据库")])]),t._v(" "),r("li",[r("p",[t._v("服务器返回相应，304 或 200")])]),t._v(" "),r("li",[r("p",[t._v("浏览器获得 HTML")])]),t._v(" "),r("li",[r("p",[t._v("解析 HTML 生成 DOM Tree，下载 MIME 文件，设置缓存")])]),t._v(" "),r("li",[r("p",[t._v("CSS 合并 DOM Tree 进行布局和绘制，JS 执行")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"项目环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#项目环境","aria-hidden":"true"}},[this._v("#")]),this._v(" 项目环境")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"单线程和多线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单线程和多线程","aria-hidden":"true"}},[this._v("#")]),this._v(" 单线程和多线程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"qz-tray-打印机库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#qz-tray-打印机库","aria-hidden":"true"}},[this._v("#")]),this._v(" QZ-Tray 打印机库")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"单元测试原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单元测试原则","aria-hidden":"true"}},[this._v("#")]),this._v(" 单元测试原则")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[e("p",[this._v("单一职责。 如果一段代码承担的职责越多，为其编写单元测试的时候就要构造更多的输入数据，然后推测它的输出。比如，一段代码中既包含数据库的连接，也包含查询，那么为它编写测试用例就要同时关注数据库连接和数据库查询。较好的方式是将这两种职责进行解耦分离，变成两个单一职责的方法，分别测试数据库连接和数据库查询。")])]),this._v(" "),e("li",[e("p",[this._v("接口抽象。 通过对程序代码进行接口抽象后，我们可以针对接口进行测试，而具体代码实现的变化不影响为接口编写的单元测试。")])]),this._v(" "),e("li",[e("p",[this._v("层次分离。 层次分离实际上是单一职责的一种实现。在MVC结构的应用中，就是典型的层次分离模型，如果不分离各个层次，无法想象这个代码该如何切入测试。通过分层之后，可以逐层测试，逐层保证")])])])}],!1,null,null,null);e.default=a.exports}}]);